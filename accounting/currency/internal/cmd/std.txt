package currency

/*-------------------------------+
| Code generated by std_currency |
|          DO NOT EDIT           |
+-------------------------------*/

import (
	"fmt"
	"strings"
)

// Currency defines a currency containing
// It's code, taken from the constants above
// as well as it's minor units, as an integer.
type Currency struct {
    code string
    minorUnits int
    factor int
}

// Code returns the currency code to the user
func (c Currency) Code() string { return c.code }

// MinorUnits returns the minor unit to the user
func (c Currency) MinorUnits() int { return c.minorUnits }

// Factor returns the factor by which a float should be multiplied
// to get back to it's smallest denomination
//
// Example:
//  pence := 100.00 * currency.GBP.Factor()
func (c Currency) Factor() int { return c.factor }

// FactorAsInt64 returns the factor, converted to a int64
func (c Currency) FactorAsInt64() int64 { return int64(c.factor) }

// FactorAsFloat64 returns the factor, converted to a float64
func (c Currency) FactorAsFloat64() float64 { return float64(c.factor) }

// Get returns a currency struct if the provided
// code is contained within the valid codes. Otherwise
// an error will be returned
func Get(code string) (Currency, error) {
    if Valid(code) {
        val, ok := currencies[code]
        if ok {
            return val, nil
        }
    }
    return Currency{}, fmt.Errorf("currency: could not find currency with code: %q", code)
}

// Valid checks if a provided code is contained
// inside the provided ValidCodes slice
func Valid(code string) bool {
	for _, c := range ValidCodes {
		if strings.EqualFold(c, code) {
			return true
		}
	}
    return false
}

// Following are all the structs containing currency data
var (
    {{ range $k, $v := . -}}
        // {{$v.Code}} currency struct
        {{$v.Code}} = Currency{ code: "{{$v.Code}}", minorUnits: {{$v.Units}}, factor: {{$v.Factor}}}
    {{ end }}
)

var currencies = map[string]Currency{
    {{ range $k, $v := . -}}
        "{{$v.Code}}": {{$v.Code}},
    {{ end }}
}

// ValidCodes is provided so that you may build your own validation against it
var ValidCodes = []string{
    {{ range $k, $v := . -}}
        "{{$v.Code}}",
    {{ end }}
}
